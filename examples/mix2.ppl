data Char = a | b | c;
data String = Nil | Cons Char String;
data Streeng = Eps | Trm Char | Cat Streeng Streeng | And Streeng Streeng;
data Maybe a = None | Some a;

define streeqh st s =
  case st of
    | Eps -> Some s
    | Trm c -> (case s of Nil -> None | Cons c' s -> if c == c' then Some s else None)
    | Cat st1 st2 ->
      let s' = streeqh st1 s in
        (case s' of None -> None | Some s' -> streeqh st2 s')
    | And st1 st2 ->
      (case streeqh st1 s of None -> None | Some s' ->
        (case streeqh st2 s of None -> None | Some s'' ->
          if s' == s'' then Some s' else None));
define streeq st s =
  let s' = streeqh st s in
    case s' of None -> False | Some s' -> case s' of Nil -> True | Cons _ _ -> False;

define M = amb
  (let (X, Y, Z, W) = M in let T = one in ((Cat X T), Y, Z, (Cat (Trm a) W))) -- M(XT,Y,Z,aW) -> M(X,Y,Z,W)one(T)
  (let (X, Y, Z, W) = M in let T = one in (X, (Cat Y T), Z, (Cat (Trm b) W))) -- M(X,YT,Z,bW) -> M(X,Y,Z,W)one(T)
  (let (X, Y, Z, W) = M in let T = one in (X, Y, (Cat Z T), (Cat (Trm c) W))) -- M(X,Y,ZT,cW) -> M(X,Y,Z,W)one(T)
  ((Eps, Eps, Eps, Eps)) -- M(,,,) -> 
  ;
define S = 
  (let (X, A) = S' in (And A X)) -- S(X) -> S'(X,X)
  ;
define S' = 
  (let (X, Y) = eqlen in let (A, Z) = eqlen in let (B, C, D, W) = M in (W, (Cat (And D (And C (And B (And A X)))) (Cat Y Z)))) -- S'(W,XYZ) -> eqlen(X,Y)eqlen(X,Z)M(X,X,X,W)
  ;
define _ANY_ = amb
  (Eps) -- _ANY_() -> 
  (let X = _ANY_ in let Y = _ANY_ in (Cat X Y)) -- _ANY_(XY) -> _ANY_(X)_ANY_(Y)
  ((Trm a)) -- _ANY_(a) -> 
  ((Trm b)) -- _ANY_(b) -> 
  ((Trm c)) -- _ANY_(c) -> 
  ;
define eqlen = amb
  ((Eps, Eps)) -- eqlen(,) -> 
  (let W = one in let Y = one in let (X, Z) = eqlen in ((Cat W X), (Cat Y Z))) -- eqlen(WX,YZ) -> one(W)one(Y)eqlen(X,Z)
  ;
define one = amb
  ((Trm a)) -- one(a) -> 
  ((Trm b)) -- one(b) -> 
  ((Trm c)) -- one(c) -> 
  ;
streeq S (Cons a (Cons a (Cons a (Cons a Nil))))
