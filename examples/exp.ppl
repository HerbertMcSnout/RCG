data Char = a;
data String = Nil | Cons Char String;
data Streeng = Eps | Trm Char | Cat Streeng Streeng | And Streeng Streeng;
data Maybe a = None | Some a;

define streeqh st s =
  case st of
    | Eps -> Some s
    | Trm c -> (case s of Nil -> None | Cons c' s -> if c == c' then Some s else None)
    | And st1 st2 ->
      (case streeqh st1 s of None -> None | Some s' -> (case streeqh st2 s of None -> None | Some s'' -> if s' == s'' then Some s' else None))
    | Cat st1 st2 ->
      (case streeqh st1 s of None -> None | Some s' -> streeqh st2 s');
define streeq st s =
  let s' = streeqh st s in
    case s' of None -> False | Some s' -> case s' of Nil -> True | Cons _ _ -> False;

define EQ = amb
  (let (X, Y) = EQ in ((Cat (Trm a) X), (Cat (Trm a) Y))) -- EQ(aX,aY) -> EQ(X,Y)
  ((Eps, Eps)) -- EQ(,) -> 
  ;
define S = amb
  (let (X, Y) = EQ in let X' = S in ((Cat (And X X') Y))) -- S(XY) -> EQ(X,Y)S(X)
  ((Eps)) -- S() -> 
  ;
streeq S (Cons a (Cons a (Cons a (Cons a Nil))))




{-data Char = a;
data String = Nil | Cons Char String;
data Maybe a = None | Some a;
data Nat = Zero | Succ Nat;

data Substring = Range Nat String;

-- S(XY) -> EQ(X, Y) S(X)

define length s = case s of Nil -> Zero | Cons _ s -> Succ (length s);

define split s = amb
  (Range Zero Nil, Range (length s) s)
  (case s of
    | Nil -> fail
    | Cons c s ->
      let (ss1, ss2) = split s in
        case ss1 of Range l1 s1 ->
          case ss2 of Range l2 s2 ->
            
  );

define EQ X Y = case X of
  | Nil -> ()
  | Cons c1 X' -> case Y of
    | Nil -> ()
    | Cons c2 Y' ->
      -}